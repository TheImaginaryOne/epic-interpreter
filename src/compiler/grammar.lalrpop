use crate::compiler::ast::{Statement, assign, Identifier, Spanned, Expr, UnaryOp, BinaryOp, Literal, binary, unary, literal};
use std::str::FromStr;

grammar;

pub Program: Vec<Statement> = {
    <Stmt*> => <>
}
Stmt: Statement = {
    "let" <i:Sp<Ident>> "=" <e:Expr> ";" => {
        Statement::LetDecl(i, e)
    },
    <Expr> ";" => Statement::ExprStmt(<>)
}
// @L means left location, @R means right location,
// the parser will add this information into the AST
pub Expr: Spanned<Expr> = {
    Assign => <>,
}
Assign: Spanned<Expr> = {
    Equal => <>,
    <@L> <Sp<Ident>> "=" <Equal> <@R> => assign(<>)
}
Equal: Spanned<Expr> = {
    Compare => <>,
    @L Equal Sp<EqOp> Compare @R => binary(<>),
}
Compare: Spanned<Expr> = {
    @L Compare Sp<CompareOp> Add @R => binary(<>),
    Add => <>,
}
Add: Spanned<Expr> = {
    @L Add Sp<AddOp> Mul @R => binary(<>),
    Mul => <>,
}
Mul: Spanned<Expr> = {
    @L Mul Sp<MulOp> Unary @R => binary(<>),
    Unary => <>,
}
Unary: Spanned<Expr> = {
    Primary => <>,
    @L Sp<UnaryOp> Primary @R => unary(<>),
}
Primary: Spanned<Expr> = {
    "(" <Expr> ")",
    <l:@L> <i:Ident> <r:@R> => Spanned::new(l, Expr::Identifier(i), r),
    @L Integer @R => literal(<>),
}

// utility
Sp<R>: Spanned<R> = {
    @L R @R => Spanned::new(<>),
}
Integer: Literal = {
    r"[0-9]+" => Literal::Int(i32::from_str(<>).unwrap())
}
UnaryOp: UnaryOp = {
    "-" => UnaryOp::Neg
}
MulOp: BinaryOp = {
    "*" => BinaryOp::Mul,
    "/" => BinaryOp::Div,
}
AddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}
CompareOp: BinaryOp = {
    ">" => BinaryOp::Gt,
    "<" => BinaryOp::Lt,
}
EqOp: BinaryOp = {
    "==" => BinaryOp::Eq
}
Ident: Identifier = {
    <name:r"[a-zA-Z]+"> => Identifier { name: name.to_string() }
}
