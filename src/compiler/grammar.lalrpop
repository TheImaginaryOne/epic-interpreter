use crate::compiler::ast::*;
use std::str::FromStr;
use crate::compiler::error::Error as CompileError;
use crate::compiler::lexer::{Lexer, Token};
use lalrpop_util::ParseError;

grammar<'a>(input: &'a str);

extern {
    type Location = usize;
    type Error = (usize, CompileError, usize);
    
    enum Token {
        "string" => Token::String,
        "integer" => Token::Integer,
        "identifier" => Token::Identifier,

        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        ";" => Token::Semicolon,

        "=" => Token::Equal,
        "==" => Token::DoubleEqual, // '=='
        "<" => Token::Less,
        ">" => Token::Greater,
        "let" => Token::Let,
        "if" => Token::If,
        "else" => Token::Else,
    }
}

pub Program: Vec<Spanned<Statement>> = {
    <Statement*> => <>
}
Statement: Spanned<Statement> = {
    <l:@L> "let" <i:Sp<Ident>> "=" <e:Expression> ";" <r:@R> => {
        Spanned::new(l, Statement::LetBinding(i, e), r)
    },
    <l:@L> <e:Expression> ";" <r:@R> => {
        Spanned::new(l, Statement::Expression(e), r)
    },
    Sp<IfElseStatement> => <>,
    Sp<BlockStatement> => <>,
}

IfStuffElse: (Spanned<Expression>, Spanned<Block>) = {
    "if" <e:Expression> <b:Sp<Block>> "else" => (e, b)
}
IfElseStatement: Statement = {
    <a:(IfStuffElse)+> <b:(Sp<Block>)> => {
        Statement::IfElse(Box::new(IfElse {
            then_clauses: a,
            else_clause: Some(b),
        }))
    },
    "if" <e:Expression> <b:Sp<Block>>  => {
        Statement::IfElse(Box::new(IfElse {
            then_clauses: vec![(e, b)],
            else_clause: None,
        }))
    }
}
Block: Block = {
    "{" <s:Statement*> "}" => Block { statements: s }
}
// A Block wrapped in a Statement.
BlockStatement: Statement = {
    Block => Statement::Block(<>)
}
// @L means left location, @R means right location,
// the parser will add this information into the AST
pub Expression: Spanned<Expression> = {
    Assign => <>,
}
Assign: Spanned<Expression> = {
    Equal => <>,
    <@L> <Sp<Ident>> "=" <Equal> <@R> => assign(<>)
}
Equal: Spanned<Expression> = {
    Compare => <>,
    @L Equal Sp<EqualOp> Compare @R => binary(<>),
}
Compare: Spanned<Expression> = {
    @L Compare Sp<CompareOp> Add @R => binary(<>),
    Add => <>,
}
Add: Spanned<Expression> = {
    @L Add Sp<AddOp> Multiply @R => binary(<>),
    Multiply => <>,
}
Multiply: Spanned<Expression> = {
    @L Multiply Sp<MultiplyOp> Unary @R => binary(<>),
    Unary => <>,
}
Unary: Spanned<Expression> = {
    Primary => <>,
    @L Sp<UnaryOp> Primary @R => unary(<>),
}
Primary: Spanned<Expression> = {
    "(" <Expression> ")",
    <l:@L> <i:Ident> <r:@R> => Spanned::new(l, Expression::Identifier(i), r),
    @L Integer @R => literal(<>),
    @L String @R => literal(<>),
}

// utility
Sp<R>: Spanned<R> = {
    @L R @R => Spanned::new(<>),
}
Integer: Literal = {
    <l:@L> <i:"integer"> <r:@R> =>? i32::from_str("")
            .map_err(|_| ParseError::User {
                error: (l, CompileError::CannotParseInteger, r)
            })
            .and_then(|x| Ok(Literal::Integer(x)))
}
String: Literal = {
    "string" => Literal::String("".into())
}
UnaryOp: UnaryOp = {
    "-" => UnaryOp::Negate
}
MultiplyOp: BinaryOp = {
    "*" => BinaryOp::Multiply,
    "/" => BinaryOp::Divide,
}
AddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Subtract,
}
CompareOp: BinaryOp = {
    ">" => BinaryOp::Greater,
    "<" => BinaryOp::Less,
}
EqualOp: BinaryOp = {
    "==" => BinaryOp::Equal
}
Ident: Identifier = {
    "identifier" => Identifier { name: "".into() }
}
