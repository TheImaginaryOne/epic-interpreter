use crate::compiler::ast::{Statement, assign, Identifier, Spanned, Expression, UnaryOp, BinaryOp, Literal, binary, unary, literal};
use std::str::FromStr;

grammar;

pub Program: Vec<Statement> = {
    <Statement*> => <>
}
Statement: Statement = {
    "let" <i:Sp<Ident>> "=" <e:Expression> ";" => {
        Statement::LetBinding(i, e)
    },
    <Expression> ";" => Statement::Expression(<>)
}
// @L means left location, @R means right location,
// the parser will add this information into the AST
pub Expression: Spanned<Expression> = {
    Assign => <>,
}
Assign: Spanned<Expression> = {
    Equal => <>,
    <@L> <Sp<Ident>> "=" <Equal> <@R> => assign(<>)
}
Equal: Spanned<Expression> = {
    Compare => <>,
    @L Equal Sp<EqualOp> Compare @R => binary(<>),
}
Compare: Spanned<Expression> = {
    @L Compare Sp<CompareOp> Add @R => binary(<>),
    Add => <>,
}
Add: Spanned<Expression> = {
    @L Add Sp<AddOp> Multiply @R => binary(<>),
    Multiply => <>,
}
Multiply: Spanned<Expression> = {
    @L Multiply Sp<MultiplyOp> Unary @R => binary(<>),
    Unary => <>,
}
Unary: Spanned<Expression> = {
    Primary => <>,
    @L Sp<UnaryOp> Primary @R => unary(<>),
}
Primary: Spanned<Expression> = {
    "(" <Expression> ")",
    <l:@L> <i:Ident> <r:@R> => Spanned::new(l, Expression::Identifier(i), r),
    @L Integer @R => literal(<>),
}

// utility
Sp<R>: Spanned<R> = {
    @L R @R => Spanned::new(<>),
}
Integer: Literal = {
    r"[0-9]+" => Literal::Integer(i32::from_str(<>).unwrap())
}
UnaryOp: UnaryOp = {
    "-" => UnaryOp::Negate
}
MultiplyOp: BinaryOp = {
    "*" => BinaryOp::Multiply,
    "/" => BinaryOp::Divide,
}
AddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Subtract,
}
CompareOp: BinaryOp = {
    ">" => BinaryOp::Greater,
    "<" => BinaryOp::Less,
}
EqualOp: BinaryOp = {
    "==" => BinaryOp::Equal
}
Ident: Identifier = {
    <name:r"[a-zA-Z]+"> => Identifier { name: name.to_string() }
}
